# 中山大学数据科学与计算机学院本科生实验报告

## （2018年秋季学期）

| 课程名称 | 手机平台应用开发 |   任课老师   |        郑贵锋        |
| :------: | :--------------: | :----------: | :------------------: |
|   年级   |       2016       | 专业（方向） | 软件工程（数字媒体） |
|   学号   |     15335055     |     姓名     |        黄紫菱        |
|   电话   |   13611492110    |    Email     |   317681038@qq.com   |
| 开始日期 |      2018/       |   完成日期   |      2019/1/22       |

------

## 一、个人贡献

1. 完成登陆界面和登陆部分的功能实现
2. 完成主界面和主界面的功能实现
3. 完成申请的相关界面和功能实现
4. 在后期修改应用的bug

------

## 二、功能代码

1. 登陆

   1. 添加进入应用的显示

      1. 将StartActivity作为点进应用打开的activity

         ```java
         <activity android:name=".Login.StartActivity">
                     <intent-filter>
                         <action android:name="android.intent.action.MAIN" />
         
                             <category android:name="android.intent.category.LAUNCHER" />
                                 </intent-filter>
                 </activity>
         ```

      2. 在StartActivity设置两秒后进入登陆界面

         ```java
         new android.os.Handler().postDelayed(new Runnable() {
             public void run() {
                 StartActivity.this.startActivity(mainIntent);
                 StartActivity.this.finish();
             }
         
         }, SPLASH_DISPLAY_LENGHT);
         ```

   2. 登陆和注册

      1. 这里登陆和注册是通过切换 fragment 来实现的，其中，切换 fragment 的方式。这个是显示注册fragment 的部分。

         ```java
         FragmentTransaction transaction = getFragmentManager().beginTransaction();
         if(signFragment==null){
             signFragment = new SignFragment();
         }
         transaction.replace(com.example.jason.finalproj.R.id.fragmelayout,signFragment);
         transaction.addToBackStack(null).commit();
         ```

      2. 登录界面

         1. 登陆功能

            1. 子线程

               1. 使用接口函数 isaccount 判断该用户名是否注册，否则向主进程报错：账号不存在

                  ```java
                  if (mydb.isaccount(account, con)) {
                      ...
                  } else handler.obtainMessage(DHACCOUNT).sendToTarget();
                  ```

               2. 使用接口函数 confirmPassword 判断这个密码是否是这个用户名的密码，否则向主进程报错：密码错误，如果是这个用户名的密码，获得UID，告知主进程登陆成功

                  ````java
                  if (mydb.confirmPassword(account, pwd, con)) {
                      Message mesege = new Message();
                      mesege.what = LOADSUCCESSED;
                      mesege.arg1 = mydb.getUidByAccount(account, con);
                      handler.sendMessage(mesege);
                      mydb.closeConnection(con);
                  } else handler.obtainMessage(LOADFAILED).sendToTarget();
                  ````

               3. 如果接收到抛出，向主进程报错：网络连接不上

                  ```java
                  catch (RuntimeException e){
                      handler.obtainMessage(RUNTIMEERRO).sendToTarget();
                  }
                  ```

            2. 主进程

               1. 遇到账号不存在：弹出提示，按钮设置为红色（后面类似）

                  ```java
                  case DHACCOUNT:
                  loginbtn.setProgress(-1);
                  Toast.makeText(getActivity(),"账号不存在",Toast.LENGTH_SHORT).show();
                  break;
                  ```

               2. 遇到密码错误：弹出提示，按钮设置为红色

               3. 遇到网络错误：弹出提示，按钮设置为红色

               4. 成功登陆：转到主界面

                  ```java
                  new android.os.Handler().postDelayed(new Runnable() {
                      public void run() {
                          ((LoginActivity) getActivity()).loadsuccessed(u_id);
                      }
                  }, 1000);
                  ```

         2. 记住密码和账号功能

            1. 获取历史密码和历史账号

               1. 获取历史账号

                  ```java
                  public void setHistoryAccount(){
                      final SharedPreferences sharedPreferences = getActivity().getSharedPreferences(SHAREDNAME,getActivity().MODE_PRIVATE);
                      Set<String> set = sharedPreferences.getStringSet("account",null);
                      if(set!=null&&!set.isEmpty()){
                          historyAccount = set.toArray(new String[set.size()]);
                      }
                      arrayAdapter = new ArrayAdapter<String>(getActivity(), android.R.layout.simple_list_item_1,historyAccount);
                      accountInput.setAdapter(arrayAdapter);
                  }
                  ```

               2. 获取历史密码（与上面类似）

               3. 填充

            2. 记住这次输入的密码和账号：这里使用 sharedPreferences 来记住密码和账号信息

               1. 记住账号

                  1. 获取曾经存过的账号列表（这个在加载页面的时候就执行了）
                  2. 将这个账户加入列表
                  3. 再存到 sharedPreferences 中

               2. 记住密码

                  ```java
                  SharedPreferences.Editor editor = sharedPreferences.edit();
                  editor.putString(nowaccount,nowpwd);
                  editor.commit();
                  ```

         3. 跳转注册

      3. 注册界面

         1. 注册：

            1. 子线程

               1. 使用接口函数 isaccount 判断是否存在用户名
               2. 使用接口函数 addUser 增加用户

               ```java
               final  Thread thread = new Thread(new Runnable() {
                   @Override
                   public void run() {
                       try{
                           Connection  con = mydb.getConnection();
                           if(mydb.isaccount(account,con)){
                               handler.obtainMessage(HASACCOUNT).sendToTarget();
                           }
                           else if(mydb.addUser(initPhoto,"unknow",sex,"","","",account,pwd,con)){
                               handler.obtainMessage(ADDSUCCESSED).sendToTarget();
                               mydb.closeConnection(con);
                           }else handler.obtainMessage(ADDFAILED).sendToTarget();
                       }catch (RuntimeException e){
                           handler.obtainMessage(RUNTIMEERRO).sendToTarget();
                       }
                   }
               });
               ```

            2. 主线程

               1. 如果有错误，报错
               2. 没有错误，和登陆类似跳转主界面

         2. 跳转登陆

2. 主界面：主界面部分一共有六个文件，其中页面分别是：关注碎片、主页碎片、主界面

   1. 主界面

      1. 加载侧边栏

         1. 设置toolbar

            ```java
            setSupportActionBar(toolbar);
            ActionBar actionBar = getSupportActionBar();
            if(actionBar != null ){
                actionBar.setDisplayHomeAsUpEnabled(true);
                // 设置toolbar左侧的头像
                setToolbarPhoto();
            }
            ```

         2. 添加侧边栏按钮点击事件函数

            ```java
            navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {
                @Override
                public boolean onNavigationItemSelected(@NonNull final MenuItem item) {
                    ...
                }
            });
            ```

      2. 获取文章

         1. 获取所有文章：这里使用接口函数 getAllarticle 来获取

         2. 获取所有用户：这里使用接口函数 getUserById 来获取

            ```java
            /**
                 * 添加所有文章
                 */
            public void setAllArticle() {
                articleList.clear();
                usersList.clear();
                a_idList.clear();
                article_datalist.clear();
                article_imagelist.clear();
                article_set = false;
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            con = db.getConnection();
                            articleList = db.getAllarticle(con);
                            Log.d("Size", String.valueOf(articleList.size()));
                            for(int i = 0 ; i < articleList.size(); i++) {
                                usersList.add(db.getUserById(articleList.get(i).getU_id(), con));
                            }
                            handler.obtainMessage(102).sendToTarget();
            
                        } catch (Exception e) {
                            Log.d("Fail", e.getMessage());
                            e.printStackTrace();
                        }
                    }
                }).start();
            }
            ```

         3. 在文章列表添加数据

            ```java
            public void addArticleList(Users users, Article article) {
                Map<String, Object> data_temp = new LinkedHashMap<>();
                //类型
                if(article.getType() == 1) data_temp.put("type", "室外");
                else if(article.getType() == 2) data_temp.put("type", "室内");
                else if(article.getType() == 3) data_temp.put("type", "个人");
                data_temp.put("name", users.getName());     //姓名
                data_temp.put("date", Utils.getStringByDate(article.getDate()));   //日期
                data_temp.put("title", article.getTitle());     //标题
                data_temp.put("body", article.getBody());       //正文
                article_datalist.add(data_temp); //将数据项加进文章数据列表中
            
                Map<String, Bitmap> image_temp = new LinkedHashMap<>();
                image_temp.put("photo", users.getPhoto());  //头像
                //徽章
                Bitmap bitmap_badge = Utils.IdToBitmap(this, R.drawable.badge);
                image_temp.put("badge", bitmap_badge);
                //状态
                if(article.getState() == 1) image_temp.put("state", Utils.IdToBitmap(this, R.drawable.recruting));
                else if(article.getState() == 0) image_temp.put("state", Utils.IdToBitmap(this, R.drawable.ending));
                //关注
                Bitmap bitmap_collection = Utils.IdToBitmap(this, R.drawable.collection);
                image_temp.put("collection", bitmap_collection);
                article_imagelist.add(image_temp);
                Log.d("data", article_datalist.get(0).get("body").toString());
            }
            ```

      3. 碎片

         1. 碎片初始化：这里使用了不停给自己发消息处理，直到文章设置好再进入主页碎片

            ```java
            if (article_set) {
                ...
            } else {
                // 一直给自己发消息
                mHandler.postDelayed(this, 10); //10ms
            }
            ```

            文章设置好后，初始化两个碎片：主页碎片要后添加，因为显示的是最上面的碎片

            ```java
            if(Attention_fragment == null) {
                Attention_fragment = new Attention();
                transaction.add(R.id.fragment_layout, Attention_fragment);
            }
            if(Home_fragment == null){
                Log.d("test", "null");
                Home_fragment = new Home();
                transaction.add(R.id.fragment_layout, Home_fragment);
            
            }
            transaction.commit();
            home_button.setSelected(true); //主页按钮状态设为点击
            ```

         2. 碎片跳转：点击主页按钮，显示主页碎片，点击关注按钮，显示关注碎片

            ```java
            @Override
            public void onClick(View v) {
                FragmentManager fragmentManager = getSupportFragmentManager();
                FragmentTransaction transaction = fragmentManager.beginTransaction();
                hideAllFragment(transaction);
                switch(v.getId()){
                    case R.id.home_layout:
                        //Toast.makeText(MainActivity.this,"test",Toast.LENGTH_SHORT).show();
                        resetSelected();
                        home_button.setSelected(true);
                        if(Home_fragment == null){
                            Home_fragment = new Home();
                            transaction.add(R.id.fragment_layout, Home_fragment);
                        }else{
                            transaction.show(Home_fragment);
                        }
                        break;
                    case R.id.me_layout:
                        resetSelected();
                        me_button.setSelected(true);
                        if(Attention_fragment == null){
                            Attention_fragment = new Attention();
                            transaction.add(R.id.fragment_layout, Attention_fragment);
                        }else{
                            transaction.show(Attention_fragment);
                        }
                        break;
                    default:break;
                }
                transaction.commit();
            }
            ```

   2. 关注碎片

      1. 显示关注列表

         1. 获取关注列表

            1. 子线程：

               1. 使用接口函数 geta_idFromAttentionByu_id 获得所有关注的文章id
               2. 使用接口函数 getArticleById 获得每个文章的信息
               3. 使用接口函数 getU_idByA_id 获得对应的文章用户信息
               4. 使用接口函数 getUserById 获得每个用户的具体信息

               ```java
               new Thread(new Runnable() {
                   @Override
                   public void run() {
                       try {
                           con = db.getConnection();
                           a_idList = db.geta_idFromAttentionByu_id(user_id, con);
                           Log.d("Attention a_idList Size", String.valueOf(a_idList.size()));
                           for (int i = 0; i < a_idList.size(); i++) {
                               articleList.add(db.getArticleById(a_idList.get(i), con));
                               u_idList.add(db.getU_idByA_id(a_idList.get(i), con ));
                               usersList.add(db.getUserById(u_idList.get(i), con));
                           }
                           handler.obtainMessage(100).sendToTarget();
                       } catch (Exception e) {
                           Log.d("fail to show Attention", e.getMessage());
                           e.printStackTrace();
                       }
                   }
               }).start();
               ```

            2. 主线程：将获得的关注的文章更新到界面上（这里用到了 在 recycleView 中显示数据 的函数）

               ```java
               if(!(articleList.isEmpty())) {
                   cardView.setVisibility(View.GONE);
                   for(int i = 0 ; i < articleList.size(); i++) {
                       a_idList.add(articleList.get(i).getId());
                       addArticleList(usersList.get(i), articleList.get(i));
                   }
                   attentionAdapter.notifyDataSetChanged();
               } else cardView.setVisibility(View.VISIBLE);
               ```

         2. 在 recycleView 中显示数据：这部分和主界面的类似

      2. 点击事件

         1. 点击进入详情

            ```java
            @Override
            public void OnClick(View view, int position) {
                Intent intent = new Intent(mainActivity, ArticleActivity.class);
                intent.putExtra("a_id", a_idList.get(position));
                intent.putExtra("u_id", user_id);
                startActivityForResult(intent,1);
                Toast.makeText(mainActivity, String.valueOf(article_datalist.get(position).get("title")) , Toast.LENGTH_SHORT).show();
            }
            ```

         2. 长按：弹出对话框，询问是否删除，点击确定就删除

            ```java
            @Override
            public void LongClick(View view, final int position) {
                AlertDialog.Builder builder = new AlertDialog.Builder(mainActivity);
                builder.setTitle("是否删除？")
                    .setPositiveButton("确定", new DialogInterface.OnClickListener() {
                        public void onClick(DialogInterface dialogInterface, int i) {
                            // 删除数据
                            deleteAttention(user_id, a_idList.get(position));
                            articleList.remove(position);
                            usersList.remove(position);
                            u_idList.remove(position);
                            a_idList.remove(position);
                            article_datalist.remove(position);
                            article_imagelist.remove(position);
                            attentionAdapter.notifyDataSetChanged();
                        }
                    })
                    .setNegativeButton("取消", new DialogInterface.OnClickListener() {
                        public void onClick(DialogInterface dialogInterface, int i) {
                            Toast.makeText(mainActivity, "取消", Toast.LENGTH_SHORT).show();
                        }
                    })
                    .create()
                    .show();
            }
            ```

            删除关注：使用了 deleteattention 接口函数

            ```java
            public void deleteAttention(final int u_id, final int a_id) {
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            con = db.getConnection();
                            boolean delete = db.deleteattention(u_id, a_id, con);
                        } catch (Exception e) {
                            Log.d("delete Attention fail", e.getMessage());
                            e.printStackTrace();
                        }
                    }
                }).start();
            }
            ```

   3. 主页碎片

      1. 图片轮播

         1. viewPager的页面切换监听器

            ```java
            Viewpager.setOnPageChangeListener(new ViewPager.OnPageChangeListener(){
                @Override
                public void onPageScrollStateChanged(int state) {
                    // TODO Auto-generated method stub
                    switch (state) {
                            // 闲置中
                        case ViewPager.SCROLL_STATE_IDLE:
                            isAutoPlay = true;
                            break;
                            // 拖动中取消自动轮播
                        case ViewPager.SCROLL_STATE_DRAGGING:
                            isAutoPlay = false;
                            break;
                            // 设置中
                        case ViewPager.SCROLL_STATE_SETTLING:
                            isAutoPlay = true;
                            break;
                    }
                }
                @Override
                public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
                    
                }
                @Override
                public void onPageSelected(int position) {
                    tips[currentPage].setBackgroundResource(R.drawable.shape_point_normal);
                    position = position % ImageIds.length;
                    currentPage=position;
                    tips[position].setBackgroundResource(R.drawable.shape_point_selected);
                }
            });
            ```

         2. 实现无限轮播：通过不停给自己发消息

            ```java
            final Handler mHandler = new Handler();
            mHandler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    if (isAutoPlay) {
                        int currentPosition = Viewpager.getCurrentItem();
            
                        if (currentPosition == Viewpager.getAdapter().getCount() - 1) {
                            // 最后一页
                            Viewpager.setCurrentItem(0);
                        } else {
                            Viewpager.setCurrentItem(currentPosition + 1);
                        }
            
                        // 一直给自己发消息
                        mHandler.postDelayed(this, 5000); //5s
                    } else {
                        // 一直给自己发消息
                        mHandler.postDelayed(this, 5000); //5s
                    }
                }
            },5000); //5s
            ```

      2. 获取并显示文章

         1. 文章列表的获取在主界面的函数里实现

         2. 显示文章也在主界面的函数里实现

         3. 绑定适配器

            ```java
            articleAdapter = new ArticleAdapter(mainActivity, R.layout.article_item, article_datalist, article_imagelist);
            /* 设置适配器 */
            recyclerView.setAdapter(articleAdapter);
            GridLayoutManager layoutManager = new GridLayoutManager(mainActivity, 1);//网格布局，每行1列
            recyclerView.setLayoutManager(layoutManager);
            ```

      3. 点击事件

         1. 点击列表：跳转文章详情

            ```java
            articleAdapter.setonItemClickListener(new ArticleAdapter.OnItemClickListener() {
                @Override
                public void OnClick(View view, int position) {
                    Intent intent = new Intent(mainActivity, ArticleActivity.class);
                    intent.putExtra("a_id", a_idList.get(position));
                    intent.putExtra("u_id", user_id);
                    startActivityForResult(intent,1);
                    Toast.makeText(mainActivity, String.valueOf(article_datalist.get(position).get("title")) , Toast.LENGTH_SHORT).show();
                }
            
                @Override
                public void LongClick(View view, int position) {
            
                }
            
                @Override
                public void AttentionOnClick(View view, int position) {
                    addAttention(a_idList.get(position));
                }
            });
            ```

            这里用到的适配器来自队友写的 ArticleAdapter，具体实现代码在队友的实验报告中

         2. 点击关注：关注文章

            1. 子线程：使用 geta_idFromAttentionByu_id 获得所有关注的文章id，通过接口函数 addattention 增加关注

               ```java
               new Thread(new Runnable() {
                   @Override
                   public void run() {
                       try {
                           con = db.getConnection();
                           add_flag = true;
                           List<Integer> Attention_aid = db.geta_idFromAttentionByu_id(user_id, con);
                           for(int i = 0; i < Attention_aid.size(); i++) {
                               if(a_id == Attention_aid.get(i)) add_flag = false;
                           }
                           if(add_flag) {
                               add_flag = db.addattention(user_id, a_id, con);
                           }
                           handler.obtainMessage(100).sendToTarget();
                       } catch (Exception e) {
                           e.printStackTrace();
                       }
                   }
               }).start();
               ```

            2. 主线程：给出关注成功或者失败的提示

               ```java
               final Handler handler = new Handler() {
                   @Override
                   public void handleMessage(Message msg) {
                       super.handleMessage(msg);
                       switch (msg.what) {
                           case 100: //添加关注
                               if(add_flag) {
                                   Toast.makeText(mainActivity, "关注成功", Toast.LENGTH_SHORT).show();
                                   mainActivity.getAttention_fragment().setAttentionArticle();
                               } else Toast.makeText(mainActivity, "关注失败", Toast.LENGTH_SHORT).show();
                               break;
                           default:
                               break;
                       }
                   }
               };
               ```

3. 申请：包含两个页面和两个相应的列表适配器

   1. 文章详情的申请人列表页面：这个界面用于显示申请加入这个文章所描述的活动的用户

      1. 获取文章的申请人并显示

         1. 子线程：通过接口函数 getAllapplyById 获得所有申请人的id，通过接口函数 getUserById 获得每个申请人的详细信息

            ```java
            final Thread thread=new Thread(new Runnable() {
                @Override
                public void run() {
                    Connection con=mydb.getConnection();
                    allapply_id=mydb.getAllapplyById(a_id,con);
                    Log.d("test", String.valueOf(allapply_id.size()));
                    Log.d("test1", String.valueOf(a_id));
                    for(int i=0;i<allapply_id.size();i++)
                    {
                        apply_list_temp.add(mydb.getUserById(allapply_id.get(i),con));
                    }
                    handler.obtainMessage(123).sendToTarget();
                    mydb.closeConnection(con);
                }
            });
            thread.start();
            ```

         2. 主线程：将之前获得的列表显示出来

            ```java
            handler=new Handler() {
                @Override
                public void handleMessage(Message msg) {
                    super.handleMessage(msg);
                    switch (msg.what){
                        case 123:
                            for(int i=0;i<apply_list_temp.size();i++)
                            {
                                rc_adapter.addiItem(apply_list_temp.get(i));
                            }
                            progressBar1.setVisibility(View.INVISIBLE);
                            break;
                    }
                }
            };
            ```

      2. 点击事件

         1. 点击：进入这个用户的详页

            ```java
            @Override
            public void onItemClick(View view, int position) {
                Intent newIntent = new Intent(Applicant_list_Activity.this, PersonalCenter.class);
                newIntent.putExtra("u_id",
                                   rc_adapter.getItem(position).getId());
                startActivity(newIntent);
                overridePendingTransition(R.anim.anim_in,R.anim.anim_out);
            }
            ```

         2. 长按：判断你是否是这个文章的发起者，如果是弹出对话框，询问你是否删除，点击确定删除申请人。如果你不是这个文章发起者，无权删除申请人

            ```java
            @Override
            public void onItemLongClick(View view, final int position) {
                if(is_publisher){
                    AlertDialog.Builder dialog = new AlertDialog.Builder(Applicant_list_Activity.this);
                    dialog.setMessage("从申请列表中移除"+apply_list.get(position).getName());
                    dialog.setCancelable(false);
                    dialog.setPositiveButton("确认", new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialogInterface, int i) {
                            final Context context = apply_recyclerView.getContext();
                            final LayoutAnimationController controller =
                                AnimationUtils.loadLayoutAnimation(context, R.anim.layout_animation_fall_down);
                            apply_recyclerView.setLayoutAnimation(controller);
                            new Thread(new Runnable() {
                                @Override
                                public void run() {
                                    DB db=new DB();
                                    Connection con=db.getConnection();
                                    db.cancleapply(a_id,u_id,con);
                                    db.closeConnection(con);
                                }
                            }).start();
                            rc_adapter.deleteItem(position);
                        }
                    });
                    dialog.setNegativeButton("取消", new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialogInterface, int i) {
                            Toast.makeText(Applicant_list_Activity.this, "你选择了： [取消]", Toast.LENGTH_SHORT).show();
                        }
                    });
                    dialog.show();
                }
                else {
                    AlertDialog.Builder mdialog = new AlertDialog.Builder(Applicant_list_Activity.this);
                    mdialog.setMessage("你不是发布人，无法删除申请人"+apply_list.get(position).getName());
                    mdialog.setCancelable(false);
                    mdialog.setPositiveButton("确认", new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialogInterface, int i) {
                        }
                    });
                    mdialog.show();
                }
            ```

   2. 我的申请页面：这个页面用于显示你的所有申请的活动

      1. 获得申请列表并显示

         1. 获得申请列表

            1. 子线程：通过接口函数 getAllA_IdFromApplyByU_Id 获得该用户的所有申请的id，通过接口函数 getArticleById getU_idByA_id getUserById 分别获得文章内容、用户ID和用户详情

               ```java
               new Thread(new Runnable() {
                   @Override
                   public void run() {
                       try {
                           Connection con = db.getConnection();
                           applicationList = db.getAllA_IdFromApplyByU_Id(user_id, con);
                           Log.d("ApplicationSize", String.valueOf(applicationList.size()));
                           for(int i = 0 ; i < applicationList.size(); i++) {
                               articleList.add(db.getArticleById(applicationList.get(i), con));
                               a_userList.add(db.getU_idByA_id(applicationList.get(i), con));
                               usersList.add(db.getUserById(a_userList.get(i), con));
                           }
                           Log.d("ArticleSize", String.valueOf(articleList.size()));
                           Log.d("A_userSize", String.valueOf(a_userList.size()));
                           Log.d("UsersSize", String.valueOf(usersList.size()));
                           handler.obtainMessage(100).sendToTarget();
                           db.closeConnection(con);
                       } catch (Exception e) {
                           Log.d("Fail", e.getMessage());
                           e.printStackTrace();
                       }
                   }
               }).start();
               ```

            2. 主线程：调用添加数据函数为申请列表添加数据

         2. 为申请列表添加数据

            ```java
            public void addApplicationList(Users users, Article article) {
                Map<String, Object> data_temp = new LinkedHashMap<>();
                //类型
                if(article.getType() == 1) data_temp.put("type", "室外");
                else if(article.getType() == 2) data_temp.put("type", "室内");
                else if(article.getType() == 3) data_temp.put("type", "个人");
                data_temp.put("name", users.getName());     //姓名
                data_temp.put("date", Utils.getStringByDate(article.getDate()));   //日期
                data_temp.put("title", article.getTitle());     //标题
                data_temp.put("body", article.getBody());       //正文
                application_datalist.add(data_temp); //将数据项加进文章数据列表中
            
                Map<String, Bitmap> image_temp = new LinkedHashMap<>();
                image_temp.put("photo", users.getPhoto());  //头像
                //申请状态 （应加入数据库）
                if(article.getState() == 2) image_temp.put("state", Utils.IdToBitmap(this, R.drawable.access));
                else if(article.getState() == 1) image_temp.put("state", Utils.IdToBitmap(this, R.drawable.auditing));
                else if(article.getState() == 0) image_temp.put("state", Utils.IdToBitmap(this, R.drawable.refuse));
                application_imagelist.add(image_temp);
            }
            ```

         3. 更新UI：通过不断给自己发消息直到申请设置好了再更新UI

            ```java
            final Handler mHandler = new Handler();
            mHandler.post(new Runnable() {
                @Override
                public void run() {
                    if (applcattion_set) {
                        applicationAdapter.notifyDataSetChanged();
                        if(application_datalist.size() == 0) cardView.setVisibility(View.VISIBLE);
                        else cardView.setVisibility(View.GONE);
                    } else {
                        // 一直给自己发消息
                        mHandler.postDelayed(this, 10); //10ms
                    }
                }
            });
            ```

      2. 返回按钮：结束这个页面

         ```java
         @Override
         public boolean onOptionsItemSelected(MenuItem item) {
             switch (item.getItemId()) {
                 case android.R.id.home:
                     setResult(2);
                     finish();
                     break;
         
                 default:break;
             }
             return true;
         }
         ```

------

## 三、遇到的问题与解决方案

1. 主页的更新信息

   由于主页设置的原因，主页的回调函数并不能被执行，因此只能通过将主页碎片先删除再重新新建一个的方式来更新。

   而在更新的部分，我统一了所有会影响主页列表的页面跳转的函数，使得 resultcode 都是 2 ，然后在主页的 onActivityResult 函数中更新相应列表信息。

   ```java
   @Override
   protected void onActivityResult(int requestCode, int resultCode, Intent data){
       super.onActivityResult(requestCode,resultCode,data);
       Log.d("requestCode", String.valueOf(requestCode));
       Log.d("resultCode", String.valueOf(resultCode));
       if(requestCode == 1 && resultCode == 2){
           setNavHeader();
           setToolbarPhoto();
           setAllArticle();
           setHome_fragment();
           //Home_fragment.update();
           Log.d("MainActivity", "更新主界面");
       }
   }
   
   //更新碎片
   final Handler mHandler = new Handler();
           mHandler.post(new Runnable() {
               @Override
               public void run() {
                   if (article_set) {
                       article_set = false;
                       FragmentManager fragmentManager = getSupportFragmentManager();
                       FragmentTransaction transaction = fragmentManager.beginTransaction();
                       if(Attention_fragment == null) {
                           Attention_fragment = new Attention();
                           transaction.add(R.id.fragment_layout, Attention_fragment);
                       }
                       if(Home_fragment == null){
                           Log.d("test", "null");
                           Home_fragment = new Home();
                           transaction.add(R.id.fragment_layout, Home_fragment);
   
                       }else{
                           Log.d("test", "not null");
                           //transaction.show(Home_fragment);
                           //先将旧的删除
                           transaction.remove(Home_fragment);
                           Home_fragment = new Home();
                           //重新New一个碎片再显示出来
                           transaction.add(R.id.fragment_layout, Home_fragment);
                       }
                       transaction.commit();
   
                       home_button.setSelected(true); //主页按钮状态设为点击
                   } else {
                       // 一直给自己发消息
                       mHandler.postDelayed(this, 10); //10ms
                   }
               }
           });
   ```

   然后将所有可能修改的部分修改：添加文章、文章详情的返回按钮

2. 更新界面

   一开始我并没有使用不断给自己发信息直到做好了再更新UI，导致会出问题。后来经过询问同学，发现可以不断给自己发送消息然后等到更新好了才更新UI

------

## 四、个人总结与个人贡献评分

这次的项目不像期中项目一样，是规定好题目和要求的，而期末项目就是自由发挥的，因此我们组在决定做什么上面也讨论了一段时间，最后决定做一个实用性的app。后面就是写代码的部分了，这次的代码量对比期中的多很多，不过这次也是和期中项目一样，并不是每一个页面都是用一个activity来实现的，而是用碎片来实现，而且这次的项目涉及到的功能有很多，因此我们代码文件的划分上是以功能划分，但是这样会让我们页面关系上需要非常多的小组沟通，但是在写的过程中会比较好，因为涉及到的函数会非常类似。

后期部分我主要做的是整个APP的bug的修改，由于我们不同部分做的人不一样，整个APP涉及到很多页面间的交互，因此会存在很多在不同部分跳转上存在的问题，例如从文章详情到主页的跳转，一开始我们并没有实现回到主页更新主页UI，但是这样使用起来非常的不方便，因此我就在最后整体都做完之后增加了这个功能。而且靠这个过程，我对安卓的碎片相关有了更多的了解。

个人贡献评分：90

------

## 五、思想感悟

这次的组队过程中，算是一个比较完整的做一个项目的过程，从选择题目，决定功能，分工，后端和前端的交流，以及所有前端不同模块间的交流等，在整个过程中，交流共同变得非常重要，因为我们存在很多不同的模块交互的情况，所以需要经常性的交流和沟通。

而且在整个过程中，我们首先判断应该做什么功能，希望能做到什么效果，然后再寻找能够实现这样效果的方法，因此也学习到了很多的内容，例如前面提到的期望在获得数据完成后才更新UI，经过查找资料可以使用 handler 的方法，一直给自己发送消息（等待不更新UI），直到获得所有数据后，再更新UI。特别是后面修改整个APP的bug的时候，这种情况就经常出现了。

因此在整个项目中，我收获到了很多和队友交流的内容，我觉得这个对于以后的项目有非常好的经历。之前的合作经常都是将整个项目分成几个相对独立的模块，然后每个人做相应的模块，而这次每个人之间的联系变得更多了，因此也就需要更多的交流。

在整个学期的安卓学习过程中，我学到了很多东西，了解了安卓的开发，了解了很多安卓的内容，虽然和现代操作系统应用开发课程一样，每周都有一个作业，虽然会让整个学期很忙但是确确实实学习到很多东西，从完全不会安卓开发到最后能做出一个能用的app，确实学会了不少的东西，也对这方面产生了兴趣，也希望能更多了解一下这些东西。非常感谢老师助教队友的各种帮助，让我学会了很多东西。

------



