# 中山大学数据科学与计算机学院本科生实验报告

## （2018年秋季学期）

| 课程名称 | 手机平台应用开发 |   任课老师   |         郑贵锋         |
| :------: | :--------------: | :----------: | :--------------------: |
|   年级   |       2016       | 专业（方向） |          嵌软          |
|   学号   |     16340215     |     姓名     |          王建          |
|   电话   |   13246824607    |    Email     | jankingwon@foxmail.com |
| 开始日期 |       2018       |   完成日期   |          2018          |

------

## 一、实验题目

> 实验目的
>
> 1. 掌握 Broadcast 编程基础。
> 2. 掌握动态注册 Broadcast 和静态注册 Broadcast。
> 3. 掌握Notification 编程基础。
> 4. 掌握 EventBus 编程基础。

------

## 二、实现内容

- 在启动应用时，会有通知产生，随机推荐一个食品。
  ![preview](https://gitee.com/code_sysu/PersonalProject2/raw/master/manual/images/week7_static_notification.jpg)
- 点击通知跳转到所推荐食品的详情界面。
  ![preview](https://gitee.com/code_sysu/PersonalProject2/raw/master/manual/images/week7_static_jump.jpg)
- 点击收藏图标，会有对应通知产生，并通过Eventbus在收藏列表更新数据。
  ![preview](https://gitee.com/code_sysu/PersonalProject2/raw/master/manual/images/week7_requirement3.jpg)
- 点击通知返回收藏列表。
  ![preview](https://gitee.com/code_sysu/PersonalProject2/raw/master/manual/images/week7_requirement4.jpg)
- 实现方式要求:启动页面的通知由静态广播产生，点击收藏图标的通知由动态广播产生。

------

## 三、课堂实验结果

### (1)实验截图

![broadcast](16340215王建lab4/broadcast.gif)

### (2)实验步骤以及关键代码

#### Broadcast使用

`BroadcastReceiver`（广播接收器），属于 `Android` 四大组件之一

##### 注册的方式分为两种：**静态注册**、**动态注册**

##### 静态注册

##### 1.注册广播

创建一个`java`类`StaticReceiver`

```java
public class StaticReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        if (intent.getAction().equals("com.janking.sysuhealth.myapplication2.MyStaticFilter")){
            //代表捕获到需要的广播，内容稍后填充
        }
    }

}
```

然后在配置文件`App->manifests->AndroidManifest.xml`中加上

```xml
<receiver android:name=".StaticReceiver"
    android:enabled="true"
    android:exported="true">
    <intent-filter>
        <action android:name="com.janking.sysuhealth.myapplication2.MyStaticFilter" />
    </intent-filter>
</receiver>
```

> 这里的`com.janking.sysuhealth.myapplication2.MyStaticFilter`理论上可以自定义，只要保持一致就可以（后面还会出现）

##### 2.发送广播

这里要实现打开页面就会弹出通知并随机出现一个`Food`的名字，点击跳到其详情页面

所以在`Food`列表的`onCreate`函数(即`SecondActivity`)中加上

```java
//broadcast
Bundle bundle = new Bundle();
//把整个Food类变量放进bundle
bundle.putSerializable("broadcast_startup", mAdapter.getItem(new Random().nextInt(mAdapter.getItemCount())));//返回一个0到n-1的整数
Intent intentBroadcast = new Intent("com.janking.sysuhealth.myapplication2.MyStaticFilter"); //定义Intent
//下面这一句相当关键，这是Android8.0之后之后的写法
intentBroadcast.setComponent(new ComponentName("com.janking.sysuhealth", "com.janking.sysuhealth.StaticReceiver"));
intentBroadcast.putExtras(bundle);
sendBroadcast(intentBroadcast);
```

这里我用的API是28，即`compileSdkVersion 28`，跟之前的版本可能会**不一样**！

[关于Android SDK里的compileSdk、minSdk、targetSdk](https://blog.csdn.net/DovSnier/article/details/79870590)

##### 3.接收广播

要认识到，广播其实也是以`Intent`的方式传过来的

所以还是这样解析传过来的`Food`

```java
Bundle bundle = intent.getExtras();
Food food = (Food)bundle.getSerializable("broadcast_startup");
```

##### 4.发送通知

不管什么时候，看到`发送`、`接收`、`跳转`这些字眼就只要有**数据的传送**，一般用的是`Intent`，这里要用`PendingIntent`

> 根据字面意思就知道是延迟的`intent`，主要用来在某个事件完成后执行特定的`Action`。`PendingIntent`包含了`Intent`及`Context`，所以就算`Intent`所属程序结束，`PendingIntent`依然有效，可以在其他程序中使用。
> 常用在通知栏及短信发送系统中。



创建`PendingIntent`

```java
//获取pendingIntent
//这里继续使用Click_Food关键词，就不用再Detail里加一个判断语句了
bundle.putSerializable("Click_Food", food);
Intent mainIntent = new Intent(context, Detail.class);
mainIntent.putExtras(bundle);
PendingIntent mainPendingIntent = PendingIntent.getActivity(context, 0, mainIntent, PendingIntent.FLAG_UPDATE_CURRENT);
```

又提到`Android SDK`版本的问题了，这里是`8.0(API26)`以上的使用方法，理论上低版本的方法更容易找到，但是我们目光还是要向前看（/滑稽）

创建通知`Notification`

```java
//获取状态通知栏管理
NotificationManager manager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
//channel
String CHANNEL_ID = "channel_01";
NotificationChannel mChannel = null;
if (mChannel == null) {
    String name = "my_channel_01";//渠道名字
    String description = "my_package_first_channel"; // 渠道解释说明
    //HIGH或者MAX才能弹出通知到屏幕上
    int importance = NotificationManager.IMPORTANCE_HIGH;
    mChannel = new NotificationChannel(CHANNEL_ID, name, importance);
    mChannel.setDescription(description);
    mChannel.enableLights(true); //是否在桌面icon右上角展示小红点
    manager.createNotificationChannel(mChannel);
}
//notification
NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.mipmap.empty_star)
        .setContentTitle("今日推荐")
        .setTicker("您有一条新消息")   //通知首次出现在通知栏，带上升动画效果的
        .setContentText(food.getName())
        .setDefaults(Notification.DEFAULT_ALL)
        .setAutoCancel(true)   //设置这个标志当用户单击面板就可以让通知将自动取消
        .setContentIntent(mainPendingIntent);
//display
Notification notification = mBuilder.build();
manager.notify(0,notification);
```

> (以上三段代码都是放入`StaticReceiver`中的`if`语句中)

`mChannel = new NotificationChannel(CHANNEL_ID, name, importance);`

和

`NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(context, CHANNEL_ID)`

一定要用**同一个**`CHANNEL_ID`,不然就会出现下列错误

![1539870233846](https://janking.wang/post/android4/1539870233846.png)

------

那么现在，如果点击通知跳转到食品详情页面，`Detail.java`需要更改什么吗?

**不需要**，这就像从食品列表跳转到详情一样，解析`Food`就行了，而且我很偷懒地把从`Notification`中发出的`PendingIntent`中的`Food`关键词也设置成`Click_Food`，对`Detail`来讲，它就像从列表跳过来一样！

##### 动态注册

> 其实在Android 8.0之后是不建议用静态注册的，毕竟不灵活，所以还是关注下动态注册吧

###### 1.注册广播

创建类`DynamicReceiver`

```java
public class DynamicReceiver extends BroadcastReceiver {
    private static final String DYNAMICACTION = "com.janking.sysuhealth.myapplication2.MyDynamicFilter";
    @Override
    public void onReceive(Context context, Intent intent) {
        if (intent.getAction().equals(DYNAMICACTION)) {    //动作检测
        //稍后填充
        }
    }
}
```

在需要发送广播的类中（这里是`Detail`）添加

```java
//注册广播
IntentFilter dynamic_filter = new IntentFilter();
dynamic_filter.addAction("com.janking.sysuhealth.myapplication2.MyDynamicFilter");    //添加动态广播的Action
dynamicReceiver = new DynamicReceiver();
registerReceiver(dynamicReceiver, dynamic_filter);    //注册自定义动态广播消息
```

> 注意两个地方的`Action`要一致（下面还会出现）

###### 2.发送广播

这里发送广播的激发事件是点击了Detail中的收藏图标

![1539869840890](https://janking.wang/post/android4/1539869840890.png)

所以修改`collect.setOnClickListener`为

```java
collect.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        if(!display_food.getFavorite()){
            change++;
            Toast.makeText(Detail.this, "已收藏", Toast.LENGTH_SHORT).show();
        }
        else
            Toast.makeText(Detail.this, "重复收藏", Toast.LENGTH_SHORT).show();
        display_food.setFavorite(true);
        //发送广播
        Bundle bundle = new Bundle();
        bundle.putSerializable("broadcast_favorite", display_food);//返回一个0到n-1的整数
        Intent intentBroadcast = new Intent("com.janking.sysuhealth.myapplication2.MyDynamicFilter"); //定义Intent
        //下面一句用来发送静态广播，这里不需要
        //intentBroadcast.setComponent(new ComponentName("com.janking.sysuhealth", "com.janking.sysuhealth.DynamicReceiver"));
        intentBroadcast.putExtras(bundle);
        sendBroadcast(intentBroadcast);

    }
});
```

###### 3.接收广播

在`DynamicReceiver`中的`if`语句中添加

```java
Bundle bundle = intent.getExtras();
Food food = (Food)bundle.getSerializable("broadcast_favorite");
```

###### 4.发送通知

再添加

```java
//获取pendingIntent
Intent mainIntent = new Intent(context, SecondActivity.class);
mainIntent.putExtras(bundle);
PendingIntent mainPendingIntent = PendingIntent.getActivity(context, 0, mainIntent, PendingIntent.FLAG_UPDATE_CURRENT);

//获取状态通知栏管理
NotificationManager manager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
//channel
String CHANNEL_ID = "channel_02";
NotificationChannel mChannel = null;
//不用重复赋值
if (mChannel == null) {
    String name = "my_channel_02";//渠道名字
    String description = "my_package_second_channel"; // 渠道解释说明
    //HIGH或者MAX才能弹出通知到屏幕上
    int importance = NotificationManager.IMPORTANCE_HIGH;
    mChannel = new NotificationChannel(CHANNEL_ID, name, importance);
    mChannel.setDescription(description);
    mChannel.enableLights(true); //是否在桌面icon右上角展示小红点
    manager.createNotificationChannel(mChannel);
}
//notification
NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.mipmap.full_star)
        .setContentTitle("已收藏")
        .setTicker("您有一条新消息")   //通知首次出现在通知栏，带上升动画效果的
        .setContentText(food.getName())
        .setDefaults(Notification.DEFAULT_ALL)
        .setAutoCancel(true)   //设置这个标志当用户单击面板就可以让通知将自动取消
        .setContentIntent(mainPendingIntent);
//display
Notification notification = mBuilder.build();
manager.notify(0,notification);
```

> 其实本质上这两个广播都是一样的，只是注册方式不一样，处理方式都是差不多的

###### 5. 取消注册

这个是一定要做的，不然会出现**内存泄漏**的错误

```
E/ActivityThread: Activity com.janking.sysuhealth.Detail has leaked IntentReceiver com.janking.sysuhealth.DynamicReceiver@c408803 that was originally registered here. Are you missing a call to unregisterReceiver()?
```

![1539871075001](https://janking.wang/post/android4/1539871075001.png)

> **注意：**动态广播最好在`Activity` 的 `onResume()`注册、`onPause()`注销，当然我这里是在`Oncreate()`中注册的也行

所以在`Detail`中添加

```java
@Override
protected void onPause() {
    super.onPause();
    unregisterReceiver(dynamicReceiver);
}
```

> 重复注册、重复注销也不允许

------



#### EventBus的简单使用

其实到这里，数据同步的问题还没有解决

当点击收藏弹出消息时，点击消息只能进去`SecondActivity`（即**食品**列表）界面，现在需要它显示为**收藏食品**列表界面，并且能够更新某些食品

当然直接用广播传来的数据是可以的，不过还是要学会使用多种方法（因为其实用广播处理的话是有点难…….）

##### 1.添加依赖

在`Gradle Scripts ->build.gradle(Module: app)`中的`dependencies`添加

`implementation 'org.greenrobot:eventbus:3.0.0'`

##### 2.声明订阅方法

在需要**接收**数据的`Activity`（这里是`SecondActivity`）中添加

```java
//EventBus
@Subscribe(threadMode = ThreadMode.MAIN)
public void onMessageEvent(Food f) {
    //change RecyclerView
    mAdapter.updateData(f.getName(), f.getFavorite());
    //change listview
    myListViewAdapter.addNewItem(f);
    //change floatbutton
    isHome = false;
    mRecyclerView.setVisibility(View.INVISIBLE);
    mListView.setVisibility(View.VISIBLE);
    mButton.setImageResource(R.mipmap.mainpage);
};
```

> 不要添加到`onCreate()`方法或者其它方法中，要直接加到`Activity`类中，当做一个成员。
>
> 不然会出现错误`@Override “Annotations are not allowed here”`

这里的处理大概就是更新食品总列表中的数据（不可见）以及收藏食品列表中的元素（课件），而且改变下面的`FloatingButton`，并且使`RecyclerView`不可见，`ListView`可见

##### 3.订阅

在`SecondActivity`中添加（比如在`onCreate()`)

```java
EventBus.getDefault().register(this);
```

##### 4.发送数据

这里就是在点击Detail中的通知后返回到SecondActivity页面，想来想去，也只有一个Food类型的数据要传过来，那就在之前的`DynamicReceiver`中的`if`语句中添加一句

```java
EventBus.getDefault().post(food);
```

就能传送数据了，真的是超级简单啊！！！



### (3)实验遇到的困难以及解决思路

#### 解决列表重复的问题

在`Detail`页面中多次点击收藏图标的话，虽然我之前做了处理，弹出的`Toast`会显示“**重复收藏**”，但是每次点击都会发送广播，每次发送广播都会有一个post(food)的动作，即使不跳过去看，但是其实数据已经右`EventBus`传到了``SecondActivity`了，并且也已经处理了。

所以我想了个办法，对这一句`myListViewAdapter.addNewItem(f);`做做手脚，找到`MyListViewAdapter`中的`MyListViewAdapter`，改为

```java
public void addNewItem(Food f) {
    if(list == null) {
        list = new ArrayList<>();
    }
    for(Food i : list){
        if(i.getName().equals(f.getName())){
            notifyDataSetChanged();
            return;
        }
    }
    list.add(f);
    notifyDataSetChanged();
}
```

就**不会重复**啦！

------

## 一、实验题目

> 实验目的
>
> 1. 复习 Broadcast 编程基础。
> 2. 复习动态注册 Broadcast 和静态注册 Broadcast 。
> 3. 掌握 AppWidget 编程基础。

------

## 二、实现内容

- 在第七周任务的基础上，实现静态广播、动态广播两种改变widget内容的方法。

  #### 要求

  - widget初始情况如下：
    ![preview](https://gitee.com/code_sysu/PersonalProject2/raw/master/manual/images/week8_begin.PNG)
  - 点击widget可以启动应用，并在widget随机推荐一个食品。
    ![preview](https://gitee.com/code_sysu/PersonalProject2/raw/master/manual/images/week8_recommendation.PNG)
  - 点击widget跳转到所推荐食品的详情界面。
    ![preview](https://gitee.com/code_sysu/PersonalProject2/raw/master/manual/images/week8_jump.PNG)
  - 点击收藏图标，widget相应更新。
    ![preview](https://gitee.com/code_sysu/PersonalProject2/raw/master/manual/images/week8_update.PNG)
  - 点击widget跳转到收藏列表。
    ![preview](https://gitee.com/code_sysu/PersonalProject2/raw/master/manual/images/week8_collection.PNG)
  - 实现方式要求:启动时的widget更新通过静态广播实现，点击收藏图标时的widget更新通过动态广播实现。

------

## 三、课堂实验结果

### (1)实验截图

![GIF](https://janking.wang/post/android5/GIF-1540489328401.gif)

### (2)实验步骤以及关键代码

#### 创建一个AppWidget

`File` -> `New` -> `Widget` -> `AppWidget`

自定义命名，我命名为`MyWidget`

![1540470758342](../../../../../MyBlog/blog/source/_posts/post/android5/1540470758342.png)

就会多出三个文件

![1540470892309](../../../../../MyBlog/blog/source/_posts/post/android5/1540470892309.png)

`my_widget_info.xml`这是小部件的一些属性设置

```xml
<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    android:initialKeyguardLayout="@layout/my_widget"
    android:initialLayout="@layout/my_widget"
    android:minWidth="300dp"
    android:minHeight="50dp"
    android:previewImage="@mipmap/full_star"
    android:resizeMode="horizontal|vertical"
    android:updatePeriodMillis="86400000"
    android:widgetCategory="home_screen|keyguard"></appwidget-provider>
```

`my_widget.xml`这是小部件的外观

```xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="300dp"
    android:layout_height="80dp"
    android:background="#0000">

    <ImageView
        android:layout_width="80dp"
        android:layout_height="80dp"
        android:layout_centerVertical="true"
        android:id="@+id/widget_image"
        android:src="@mipmap/full_star"/>
    <TextView
        android:id="@+id/appwidget_text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerHorizontal="true"
        android:layout_centerVertical="true"
        android:contentDescription="@string/appwidget_text"
        android:text="@string/appwidget_text"
        android:textColor="#ffffff"
        android:textSize="15sp"
        android:textStyle="bold" />

</RelativeLayout>
```

下面就主要处理好`AppWidgetProvider`中的这些方法了

![1540471542308](../../../../../MyBlog/blog/source/_posts/post/android5/1540471542308.png)

#### 通过静态广播更新

静态比较好理解，就是直接把管理`Widget`的`java`类放进`Android`的`manifest`配置文件中，以后有什么需要更新的就去找这个类

打开`AndroidManifest.xml`，添加

```
<receiver android:name=".MyWidget">
    <intent-filter>
        <action android:name="android.appwidget.action.APPWIDGET_STARTUP"/>
        <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
    </intent-filter>
    <meta-data
        android:name="android.appwidget.provider"
        android:resource="@xml/my_widget_info" />
</receiver>
```

为了让小部件显示“`当前没有任何信息`”，修改`MyWidget.java`，添加

```java
static void updateAppWidget(Context context, AppWidgetManager appWidgetManager,
                            int appWidgetId) {

    CharSequence widgetText = context.getString(R.string.appwidget_text);
    // Construct the RemoteViews object
    RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.my_widget);
    views.setTextViewText(R.id.appwidget_text, widgetText);
    // Instruct the widget manager to update the widget
    appWidgetManager.updateAppWidget(appWidgetId, views);
}

@Override
public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
    // There may be multiple widgets active, so update all of them
    for (int appWidgetId : appWidgetIds) {
        updateAppWidget(context, appWidgetManager, appWidgetId);
        RemoteViews updateView = new RemoteViews(context.getPackageName(), R.layout.my_widget);//实例化RemoteView,其对应相应的Widget布局
        Intent i = new Intent(context, SecondActivity.class);
        PendingIntent pi = PendingIntent.getActivity(context, 0, i, PendingIntent.FLAG_UPDATE_CURRENT);
        updateView.setOnClickPendingIntent(R.id.widget_image, pi); //设置点击事件
        ComponentName me = new ComponentName(context, MyWidget.class);
        appWidgetManager.updateAppWidget(me, updateView);

    }
}
```

为了让`SecondActivity`一打开就会在更新小部件，显示“`今日推荐 xxx`”，打开`SecondActivity.java`，添加

```java
@Override
protected void onStart(){
    super.onStart();
    //broadcast
    Bundle bundle = new Bundle();
    bundle.putSerializable("widget_startup", mAdapter.getItem(new Random().nextInt(mAdapter.getItemCount())));//返回一个0到n-1的整数
    Intent widgetIntentBroadcast = new Intent();
    widgetIntentBroadcast.setAction("android.appwidget.action.APPWIDGET_STARTUP");
    widgetIntentBroadcast.setComponent(new ComponentName("com.janking.sysuhealth", "com.janking.sysuhealth.MyWidget"));
    widgetIntentBroadcast.putExtras(bundle);
    sendBroadcast(widgetIntentBroadcast);

    //很关键，因为不知道为什么有时候会调用onCreate函数,然后一切都变了
    Food f = (Food)getIntent().getSerializableExtra("widget_favorite");
    if(f != null )
        EventBus.getDefault().post(f);
}
```

> 因为`SecondActivity`设置了单例模式，所以在`onCreate`发送广播不一定成功，而每次唤醒这个`Activity`时`onStart()`总是被调用



然后处理接收广播的事件，打开`MyWidget.java`，添加

```java
@Override
public void onReceive(Context context, Intent intent) {
    super.onReceive(context, intent);
    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
    if(intent.getAction().equals("android.appwidget.action.APPWIDGET_STARTUP")){//初始化
        Bundle bundle = intent.getExtras();
        Food food = (Food)bundle.getSerializable("widget_startup");
        //获取pendingIntent
        //这里继续使用Click_Food关键词，就不用再Detail里加一个判断语句了
        bundle.putSerializable("Click_Food", food);
        Intent mainIntent = new Intent(context, Detail.class);
        mainIntent.putExtras(bundle);
        PendingIntent myPendingIntent = PendingIntent.getActivity(context, 0, mainIntent, PendingIntent.FLAG_UPDATE_CURRENT);
        RemoteViews updateView = new RemoteViews(context.getPackageName(), R.layout.my_widget);//实例化RemoteView,其对应相应的Widget布局
        updateView.setOnClickPendingIntent(R.id.widget_image, myPendingIntent); //设置点击事件
        updateView.setTextViewText(R.id.appwidget_text, "今日推荐 " + food.getName());
        ComponentName cn = new ComponentName(context, MyWidget.class);
        appWidgetManager.updateAppWidget(cn, updateView);
    }
}
```

就可以实现点击小部件跳转到`Detail`详情页面了，其中的数据传送跟之前的差不多，都是通过`Intent`中的`Bundle`

#### 通过动态广播更新

本来我是打算学动态广播的办法，新创建一个java类在代码中动态注册，确实那么做了，但是一直没有效果，想了想，如果新建一个继承`AppWidgetProvider`的话，又要写`onUpdate`,`onReceive`等方法，如果在多写几个这样的类，岂不是乱套了，通知该由谁接收？

仔细一想之后，还是放在之前的`DynamicReceiver`里面吧，毕竟只要处理一下显示和`pendingIntent`就好了



所以，打开`DynamicReceiver.java`文件，在`if`语句后面添加

```java
//if(....)
    //......
else if(intent.getAction().equals("android.appwidget.action.APPWIDGET_UPDATE")){//更新
    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
    Bundle bundle = intent.getExtras();
    Food food = (Food)bundle.getSerializable("widget_favorite");
    //获取pendingIntent
    //这里继续使用Click_Food关键词，就不用再Detail里加一个判断语句了
    Intent mainIntent = new Intent(context, SecondActivity.class);
    mainIntent.putExtras(bundle);
    PendingIntent myPendingIntent = PendingIntent.getActivity(context, 0, mainIntent, PendingIntent.FLAG_UPDATE_CURRENT);
    RemoteViews updateView = new RemoteViews(context.getPackageName(), R.layout.my_widget);//实例化RemoteView,其对应相应的Widget布局
    updateView.setOnClickPendingIntent(R.id.widget_image, myPendingIntent); //设置点击事件
    updateView.setTextViewText(R.id.appwidget_text, "已收藏 " + food.getName());
    ComponentName cn = new ComponentName(context, MyWidget.class);
    appWidgetManager.updateAppWidget(cn, updateView);
    //EventBus.getDefault().post(food);//这里不用EventBus了，因为重新打开SecondActivity后会调用OnCreate函数
}
```

上面是处理了点击收藏按钮之后Widget的更新

现在在`Detail.java`里面添加注册动态广播

```java
//注册广播
//IntentFilter dynamic_filter = new IntentFilter();
//dynamic_filter.addAction("com.janking.sysuhealth.myapplication2.MyDynamicFilter");    //添加动态广播的Action
dynamic_filter.addAction("android.appwidget.action.APPWIDGET_UPDATE");
//dynamicReceiver = new DynamicReceiver();
//registerReceiver(dynamicReceiver, dynamic_filter);    //注册自定义动态广播消息
```

并在收藏按钮的点击事件中添加

```java
collect.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
		//省略其它
        Bundle bundleWidget = new Bundle();
        bundleWidget.putSerializable("widget_favorite", display_food);//返回一个0到n-1的整数
        Intent intentBroadcastWidget = new Intent("android.appwidget.action.APPWIDGET_UPDATE"); //定义Intent
        intentBroadcastWidget.putExtras(bundleWidget);
        sendBroadcast(intentBroadcastWidget);

    }
```



### (3)实验遇到的困难以及解决思路

上次把动态广播取消注册放在了`OnPause`里面，然后运行的时候抛出了异常

```java
java.lang.RuntimeException: Unable to pause activity {com.janking.sysuhealth.DetailActivity}: java.lang.IllegalArgumentException: Receiver not registered
```

[参考了这篇博客](http://www.cnblogs.com/fengzhblog/archive/2013/07/16/3193067.html)（但其实情况不一样）

发现应该在`onDestory`里面取消注册，把`onPause`删了，然后像这样

```java
@Override
protected void onDestroy() {
    super.onDestroy();
    unregisterReceiver(dynamicReceiver);
}
```

完美！

好吧，其实不完美，Widget好多跳转来跳转去的复杂东西没有考虑好，就这样吧，核心功能实现了就好！

## 四、课后实验结果

https://janking.wang/post/android4.html

https://janking.wang/post/android5.html

------

## 五、实验思考及感想

时代在进步，技术在改变！API很关键

------

#### 作业要求

- 命名要求：学号_姓名_实验编号，例如12345678_张三_lab1.md
- 实验报告提交格式为md
- 实验内容不允许抄袭，我们要进行代码相似度对比。如发现抄袭，按0分处理